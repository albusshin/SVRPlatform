package com.SVRPlatform.service.impl;

import java.io.File;
import java.io.IOException;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.io.FileUtils;
import org.apache.struts2.ServletActionContext;

import com.SVRPlatform.Utils.HTMLTranscoder;
import com.SVRPlatform.dao.SoftwareDAO;
import com.SVRPlatform.dao.UserDAO;
import com.SVRPlatform.dao.VulnerabilityDAO;
import com.SVRPlatform.model.Software;
import com.SVRPlatform.model.User;
import com.SVRPlatform.model.Vulnerability;
import com.SVRPlatform.model.VulnerabilitySolution;
import com.SVRPlatform.service.VulnerabilitySubmitService;

public class VulnerabilitySubmitServiceImpl implements VulnerabilitySubmitService {
	private UserDAO userDAO;
	private SoftwareDAO softwareDAO;
	private VulnerabilityDAO vulnerabilityDAO;
	
	public UserDAO getUserDAO() {
		return userDAO;
	}

	public void setUserDAO(UserDAO userDAO) {
		this.userDAO = userDAO;
	}

	public SoftwareDAO getSoftwareDAO() {
		return softwareDAO;
	}

	public void setSoftwareDAO(SoftwareDAO softwareDAO) {
		this.softwareDAO = softwareDAO;
	}

	public VulnerabilityDAO getVulnerabilityDAO() {
		return vulnerabilityDAO;
	}

	public void setVulnerabilityDAO(VulnerabilityDAO vulnerabilityDAO) {
		this.vulnerabilityDAO = vulnerabilityDAO;
	}


	public Map<String, String> vulnerabilitySubmit(int userID, String digest,
			String score, String confidentialityImpact, String integrityImpact,
			String availabilityImpact, String accessComplexity,
			String authentication, String gainedAccess, String type,
			String screenshotPath, String description, String softwareName,
			String version, String language) {
		Map<String, String> map = new HashMap<String, String>();

		// check if bug information is complete
		if (description.compareTo("") == 0)
			map.put("description", "empty");
		else if (description.length() > 5000)
			map.put("description", "tooLong");
		else
			map.put("description", "OK");

		if (version.compareTo("") == 0)
			map.put("version", "empty");
		else if (version.length() > 256)
			map.put("version", "tooLong");
		else
			map.put("version", "OK");

		if (softwareName.compareTo("") == 0)
			map.put("software", "empty");
		else if (softwareName.length() > 256)
			map.put("software", "tooLong");
		else
			map.put("software", "OK");

		if (digest.compareTo("") == 0)
			map.put("digest", "empty");
		else if (digest.length() > 256)
			map.put("digest", "tooLong");
		else
			map.put("digest", "OK");

		if (language.compareTo("") == 0)
			map.put("language", "empty");
		else if (language.length() > 50)
			map.put("language", "tooLong");
		else
			map.put("language", "OK");
		
		if (score.compareTo("") == 0)
			map.put("score", "empty");
		else map.put("score", "OK");

		if (map.get("description").equals("OK")
				&& map.get("version").equals("OK")
				&& map.get("software").equals("OK")
				&& map.get("digest").equals("OK")
				&& map.get("language").equals("OK")
				&& map.get("score").equals("OK")) {
			Vulnerability vulnerability = new Vulnerability();
			User user = (User) userDAO.getByID(userID);
			float ci = 0, ii = 0, ai = 0, ac = 0, a = 0, ga = 0, t = 0;
			// check if software exists
			Software software;
			if (softwareDAO.getSoftwareByName(softwareName) == null) {
				software = new Software();
				software.setName(HTMLTranscoder.transcode(softwareName));
				softwareDAO.add(software);
			}
			software = (Software) softwareDAO.getSoftwareByName(softwareName);
			
			switch (confidentialityImpact) {
			case "Complete":
				ci = 10;
				break;
			case "Partial":
				ci = 7.5f;
				break;
			case "Little":
				ci = 5;
				break;
			case "None":
				ci = 1;
				break;
			}

			switch (integrityImpact) {
			case "Complete":
				ii = 10;
				break;
			case "Partial":
				ii = 7.5f;
				break;
			case "Little":
				ii = 5;
				break;
			case "None":
				ii = 1;
				break;
			}

			switch (availabilityImpact) {
			case "Complete":
				ai = 10;
				break;
			case "Partial":
				ai = 7.5f;
				break;
			case "Little":
				ai = 5;
				break;
			case "None":
				ai = 1;
				break;
			}

			switch (accessComplexity) {
			case "High":
				ac = 10;
				break;
			case "Medium":
				ac = 7.5f;
				break;
			case "Low":
				ac = 5;
				break;
			}

			switch (authentication) {
			case "Required":
				a = 10;
				break;
			case "Not Required":
				a = 7.5f;
				break;
			}

			switch (gainedAccess) {
			case "High":
				ga = 10;
				break;
			case "Medium":
				ga = 5;
				break;
			case "None":
				ga = 1;
				break;
			}
			
			switch (type) {
			case "Gain privileges":
				t = 10;
				break;
			case "Denial Of Service":
				t = 5;
				break;
			case "Execute Code":
				t = 1;
				break;
			}
			
			vulnerability.setDatetime(new Date());
			vulnerability.setDescription(description);
			vulnerability.setVersion(HTMLTranscoder.transcode(version));
			vulnerability.setSoftware(software);
			vulnerability.setVulnerabilityDigest((HTMLTranscoder.transcode(digest)));
			vulnerability.setUser(user);
			vulnerability.setCvssScore(Float.parseFloat(score));
			vulnerability.setConfidentialityImpact(ci);
			vulnerability.setIntegrityImpact(ii);
			vulnerability.setAvailabilityImpact(ai);
			vulnerability.setAccessComplexity(ac);
			vulnerability.setAuthentication(a);
			vulnerability.setGainedAccess(ga);
			vulnerability.setVulnerabilityTypes(t);
			vulnerability.setLanguage(HTMLTranscoder.transcode(language));
			vulnerability.setUp(0);
			vulnerability.setDown(0);

			vulnerabilityDAO.add(vulnerability);

			int year = Calendar.getInstance().get(Calendar.YEAR);
			String vulnerabilityNumber = "SVRV-" + Integer.toString(year) + "-"
					+ String.format("%1$08d", vulnerability.getVulnerabilityId());
			vulnerability.setVulnerabilityNumber(vulnerabilityNumber);
			vulnerability.setGraphAddress(("upload/v" + vulnerability.getVulnerabilityId()
					+ screenshotPath.substring(screenshotPath.indexOf("."))));
			vulnerabilityDAO.update(vulnerability);

			// struts end needs vulnerability number
			map.put("VulnerabilityNumber", vulnerabilityNumber);

			String uploadPath = ServletActionContext.getServletContext()
					.getRealPath("/");
			File fromFile = new File(new File(uploadPath), screenshotPath);
			File toFile = new File(new File(uploadPath), vulnerability.getGraphAddress());
			try {
				FileUtils.copyFile(fromFile, toFile);
				fromFile.delete();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

		return map;
	}
}
